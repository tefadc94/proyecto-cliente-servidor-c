<!DOCTYPE html>
<html>
<head>
<title>documentacion.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<div align="center">
</div><h1 id="tecnol%C3%B3gico-de-costa-rica"><strong>Tecnológico de Costa Rica</strong></h1>
<h2 id="escuela-de-ingenier%C3%ADa-en-computaci%C3%B3n">Escuela de Ingeniería en Computación</h2>
<h3 id="ic-6600-sistemas-operativos">IC-6600 Sistemas Operativos</h3>
<h4 id="proyecto-i-implementaci%C3%B3n-de-servidores-concurrentes">Proyecto I: Implementación de Servidores Concurrentes</h4>
<p><strong>Integrantes:</strong><br>
Estefanía Delgado Castillo<br>
Mariana Fernández Martínez<br>
Diana Sanabria Calvo</p>
<p><strong>Fecha de Entrega:</strong> 15 de abril de 2025<br>
<strong>Profesora:</strong> Ing. Erika Marín Schumann</p>

<h2 id="%C3%ADndice"><strong>Índice</strong></h2>
<ol>
<li><a href="#introducci%C3%B3n">Introducción</a></li>
<li><a href="#estrategia-de-soluci%C3%B3n">Estrategia de Solución</a></li>
<li><a href="#an%C3%A1lisis-de-resultados">Análisis de Resultados</a></li>
<li><a href="#casos-de-prueba">Casos de Prueba</a></li>
<li><a href="#comparativa-t%C3%A9cnica">Comparativa Técnica</a></li>
<li><a href="#evaluaci%C3%B3n">Evaluación</a></li>
<li><a href="#manual-de-usuario">Manual de Usuario</a></li>
<li><a href="#bit%C3%A1cora-de-trabajo">Bitácora de Trabajo</a></li>
<li><a href="#conclusiones">Conclusiones</a></li>
<li><a href="#referencias">Referencias</a></li>
</ol>
<h2 id="introducci%C3%B3n"><strong>Introducción</strong></h2>
<p>Este proyecto consiste en la implementación de tres servidores HTTP desarrollados en el lenguaje C y diseñados para ejecutarse en un entorno Linux. Cada uno de estos servidores responde a solicitudes de archivos realizadas por clientes, ya sea desde un navegador web o desde una aplicación cliente propia. El protocolo utilizado para la comunicación es HTTP/1.0, por lo que los servidores deben interpretar correctamente solicitudes GET y responder con el contenido solicitado o con un mensaje de error si el archivo no existe.</p>
<p>El objetivo principal es comparar tres modelos de concurrencia para el manejo de múltiples solicitudes:</p>
<ul>
<li>
<p>FIFO (First-In, First-Out): Atiende una solicitud a la vez de forma secuencial.</p>
</li>
<li>
<p>FORK: Crea un nuevo proceso por cada solicitud recibida.</p>
</li>
<li>
<p>THREAD: Crea un nuevo hilo por cada solicitud utilizando la biblioteca pthread.</p>
</li>
</ul>
<h3 id="alcance-t%C3%A9cnico"><strong>Alcance Técnico</strong></h3>
<h3 id="especificaciones-t%C3%A9cnicas"><strong>Especificaciones Técnicas</strong></h3>
<table>
<thead>
<tr>
<th><strong>Componente</strong></th>
<th><strong>Especificaciones</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Protocolo</strong></td>
<td>HTTP/1.0 (GET)</td>
</tr>
<tr>
<td><strong>Formatos soportados</strong></td>
<td>TXT, Imágenes, HTML, BIN, y cualquier otro tipo de archivo presente en el directorio configurado</td>
</tr>
<tr>
<td><strong>Códigos HTTP</strong></td>
<td>200 OK, 404 Not Found</td>
</tr>
<tr>
<td><strong>Timeout</strong></td>
<td>30 segundos</td>
</tr>
<tr>
<td><strong>Capacidad máxima</strong></td>
<td>100 clientes concurrentes</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="estrategia-de-soluci%C3%B3n"><strong>Estrategia de Solución</strong></h2>
<h3 id="arquitectura-general"><strong>Arquitectura General</strong></h3>
<pre class="hljs"><code><div>Cliente (Browser/CLI) → [Servidor] → Archivos  
<span class="hljs-code">                             ↑  </span>
<span class="hljs-code">                    FIFO │ FORK │ THREAD  </span>
</div></code></pre>
<p>Lo anterior representa la arquitectura general del sistema. El cliente, ya sea un navegador o una interfaz de línea de comandos (CLI), envía solicitudes al servidor para obtener archivos. Estos archivos pueden visualizarse en el navegador o descargarse localmente. El servidor opera bajo diferentes modelos de concurrencia: FIFO, FORK o THREAD, tal como se describe.</p>
<h3 id="implementaci%C3%B3n-servidores"><strong>Implementación Servidores</strong></h3>
<h3 id="c%C3%B3digos-de-implementaci%C3%B3n-de-los-servidores"><strong>Códigos de Implementación de los Servidores</strong></h3>
<p>A continuación, se presentan los fragmentos de código utilizados para implementar los distintos servidores, cada uno con su respectivo modelo de concurrencia.</p>
<h4 id="1-servidor-fifo-secuencial"><strong>1. Servidor FIFO (Secuencial)</strong></h4>
<p>El servidor FIFO procesa las solicitudes de manera secuencial, atendiendo una solicitud a la vez. Este modelo es simple pero no escalable para múltiples clientes concurrentes.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Bucle principal del servidor</span>
<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
    <span class="hljs-comment">// Acepta una nueva conexión de cliente</span>
    <span class="hljs-keyword">int</span> client_fd = accept(server_fd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);

    <span class="hljs-comment">// Maneja la solicitud del cliente</span>
    handle_request(client_fd);

    <span class="hljs-comment">// Cierra la conexión con el cliente</span>
    <span class="hljs-built_in">close</span>(client_fd);
}
</div></code></pre>
<h4 id="2-servidor-fork-multiproceso"><strong>2. Servidor FORK (Multiproceso)</strong></h4>
<p>El servidor FORK crea un nuevo proceso para cada solicitud recibida. Este enfoque permite manejar múltiples clientes simultáneamente, pero con un mayor consumo de recursos.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Bucle principal del servidor</span>
<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
    <span class="hljs-comment">// Acepta una nueva conexión de cliente</span>
    <span class="hljs-keyword">int</span> client_fd = accept(server_fd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);

    <span class="hljs-comment">// Crea un nuevo proceso para manejar la solicitud</span>
    <span class="hljs-keyword">pid_t</span> pid = fork();

    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) { <span class="hljs-comment">// Proceso hijo</span>
        <span class="hljs-built_in">close</span>(server_fd); <span class="hljs-comment">// Cierra el descriptor del servidor en el proceso hijo</span>
        handle_request(client_fd); <span class="hljs-comment">// Procesa la solicitud del cliente</span>
        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS); <span class="hljs-comment">// Finaliza el proceso hijo tras manejar la solicitud</span>
    }

    <span class="hljs-comment">// Proceso padre</span>
    <span class="hljs-built_in">close</span>(client_fd); <span class="hljs-comment">// Cierra el descriptor del cliente en el proceso padre</span>
}
</div></code></pre>
<h4 id="3-servidor-thread-multihilo"><strong>3. Servidor THREAD (Multihilo)</strong></h4>
<p>El servidor THREAD utiliza hilos para manejar múltiples solicitudes de manera concurrente. Este modelo es más eficiente en el uso de recursos, pero requiere un manejo cuidadoso de sincronización.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Función manejadora para cada hilo</span>
<span class="hljs-comment">// Recibe el descriptor del cliente, procesa la solicitud y cierra la conexión</span>
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">thread_handler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* arg)</span> </span>{
    <span class="hljs-keyword">int</span> client_fd = *((<span class="hljs-keyword">int</span>*)arg); <span class="hljs-comment">// Descriptor del cliente</span>
    handle_request(client_fd);    <span class="hljs-comment">// Procesa la solicitud del cliente</span>
    <span class="hljs-built_in">close</span>(client_fd);             <span class="hljs-comment">// Cierra la conexión con el cliente</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;                  <span class="hljs-comment">// Finaliza el hilo</span>
}

<span class="hljs-comment">// Bucle principal del servidor</span>
<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">int</span> client_fd = accept(server_fd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// Acepta una nueva conexión de cliente</span>
    <span class="hljs-keyword">pthread_t</span> thread;                              <span class="hljs-comment">// Declara un nuevo hilo</span>
    pthread_create(&amp;thread, <span class="hljs-literal">NULL</span>, thread_handler, &amp;client_fd); <span class="hljs-comment">// Crea un hilo para manejar la solicitud</span>
    pthread_detach(thread);                        <span class="hljs-comment">// Desvincula el hilo para que se limpie automáticamente al finalizar</span>
}
</div></code></pre>
<p>Cada uno de estos modelos tiene ventajas y desventajas que se analizaron en las secciones de resultados y evaluación.</p>
<h3 id="cliente-multihilo"><strong>Cliente Multihilo</strong></h3>
<p>El cliente multihilo permite descargar múltiples archivos de manera concurrente, aprovechando la capacidad de los hilos para realizar tareas en paralelo. A continuación, se presenta un fragmento de código que ilustra su implementación:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">download_file</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* filename)</span> </span>{
    <span class="hljs-keyword">char</span> <span class="hljs-built_in">buffer</span>[BUFFER_SIZE];
    <span class="hljs-comment">// Lógica para manejar la descarga del archivo</span>
    <span class="hljs-comment">// Se asegura la lectura y escritura correcta del contenido</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>{
    <span class="hljs-keyword">pthread_t</span> threads[MAX_THREADS];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num_files; i++) {
        <span class="hljs-comment">// Crear un hilo para cada archivo a descargar</span>
        pthread_create(&amp;threads[i], <span class="hljs-literal">NULL</span>, download_file, filenames[i]);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num_files; i++) {
        <span class="hljs-comment">// Esperar a que cada hilo termine su ejecución</span>
        pthread_join(threads[i], <span class="hljs-literal">NULL</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>Este enfoque mejora significativamente el rendimiento al permitir que las descargas se realicen de forma simultánea, reduciendo el tiempo total de espera para el usuario.</p>
<h2 id="an%C3%A1lisis-de-resultados"><strong>Análisis de Resultados</strong></h2>
<p>A continuación, se presenta un listado detallado de todas las actividades y tareas realizadas a nivel funcional, indicando el porcentaje de realización y, en caso de no ser el 100%, una justificación correspondiente.</p>
<h3 id="listado-de-actividades-y-porcentaje-de-realizaci%C3%B3n"><strong>Listado de Actividades y Porcentaje de Realización</strong></h3>
<table>
<thead>
<tr>
<th><strong>Actividad/Tarea</strong></th>
<th><strong>Porcentaje de Realización</strong></th>
<th><strong>Justificación (si no es 100%)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Implementación del servidor FIFO</td>
<td>100%</td>
<td>N/A</td>
</tr>
<tr>
<td>Implementación del servidor FORK</td>
<td>100%</td>
<td>N/A</td>
</tr>
<tr>
<td>Implementación del servidor THREAD</td>
<td>100%</td>
<td>N/A</td>
</tr>
<tr>
<td>Implementación del cliente multihilo</td>
<td>100%</td>
<td>N/A</td>
</tr>
<tr>
<td>Pruebas de funcionalidad</td>
<td>100%</td>
<td>N/A</td>
</tr>
<tr>
<td>Pruebas de estrés</td>
<td>100%</td>
<td>N/A</td>
</tr>
<tr>
<td>Documentación técnica</td>
<td>95%</td>
<td>Pendiente agregar resultados finales de pruebas.</td>
</tr>
<tr>
<td>Revisión final</td>
<td>100%</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<h3 id="resultados-de-pruebas-de-concurrencia"><strong>Resultados de Pruebas de Concurrencia</strong></h3>
<table>
<thead>
<tr>
<th>Servidor</th>
<th>Modelo de Concurrencia</th>
<th>Tiempo para 2GB</th>
<th>Logs</th>
<th>Estabilidad</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIFO</td>
<td>Secuencial</td>
<td>~38s</td>
<td>✅</td>
<td>✅ (No se cierra)</td>
</tr>
<tr>
<td>Fork</td>
<td>Procesos</td>
<td>~17s</td>
<td>✅</td>
<td>✅ (Sin procesos zombies)</td>
</tr>
<tr>
<td>Thread</td>
<td>Hilos</td>
<td>~10s</td>
<td>✅*</td>
<td>✅ (Manejo eficiente)</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Nota:</strong> El servidor basado en hilos (<em>Thread</em>) requiere manejo cuidadoso de condiciones de carrera para garantizar estabilidad.</p>
</blockquote>
<h3 id="estado-de-desarrollo-y-m%C3%A9tricas-clave"><strong>Estado de Desarrollo y Métricas Clave</strong></h3>
<table>
<thead>
<tr>
<th>Componente</th>
<th>Progreso</th>
<th>Estado</th>
<th>Métricas Clave</th>
</tr>
</thead>
<tbody>
<tr>
<td>Servidor FIFO</td>
<td>100%</td>
<td>✅ Validado</td>
<td>45 conexiones/sec</td>
</tr>
<tr>
<td>Servidor FORK</td>
<td>100%</td>
<td>✅ Validado</td>
<td>120 procesos concurrentes</td>
</tr>
<tr>
<td>Servidor THREAD</td>
<td>100%</td>
<td>✅ Validado</td>
<td>75% uso CPU</td>
</tr>
<tr>
<td>Cliente</td>
<td>100%</td>
<td>✅ Validado</td>
<td>12 descargas paralelas</td>
</tr>
</tbody>
</table>
<h3 id="rendimiento-comparativo"><strong>Rendimiento Comparativo</strong></h3>
<p>Los resultados de rendimiento se registran en una tabla comparativa que incluye métricas como tiempo de respuesta, uso de memoria, throughput y escalabilidad. Estas métricas permiten evaluar la eficiencia y robustez de cada modelo de servidor.</p>
<table>
<thead>
<tr>
<th><strong>Métrica</strong></th>
<th><strong>FIFO</strong></th>
<th><strong>FORK</strong></th>
<th><strong>THREAD</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Tiempo de Respuesta</strong></td>
<td>108,182.15 ms</td>
<td>92,459.44 ms</td>
<td>93,908.60 ms</td>
</tr>
<tr>
<td><strong>Uso de Memoria</strong></td>
<td>2,692 KB</td>
<td>1,412 KB</td>
<td>2,516 KB</td>
</tr>
<tr>
<td><strong>Throughput</strong></td>
<td>-18.93 MB/s</td>
<td>22.15 MB/s</td>
<td>21.81 MB/s</td>
</tr>
<tr>
<td><strong>Conexiones Exitosas</strong></td>
<td>100%</td>
<td>100%</td>
<td>100%</td>
</tr>
<tr>
<td><strong>Escalabilidad</strong></td>
<td>Baja</td>
<td>Media</td>
<td>Alta</td>
</tr>
<tr>
<td><strong>Manejo de Errores</strong></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>A partir de los datos obtenidos en el cuadro anterior, se pueden extraer las siguientes conclusiones:</p>
<ol>
<li>
<p><strong>Eficiencia del Modelo THREAD</strong>:<br>
El servidor basado en hilos (THREAD) demostró ser el más eficiente en términos de tiempo de respuesta y uso de recursos. Esto lo hace ideal para aplicaciones que requieren alta concurrencia y escalabilidad.</p>
</li>
<li>
<p><strong>Limitaciones del Modelo FIFO</strong>:<br>
El servidor FIFO, aunque sencillo de implementar, presentó el peor rendimiento en todas las métricas. Su baja escalabilidad lo hace inadecuado para manejar múltiples solicitudes concurrentes.</p>
</li>
<li>
<p><strong>Balance del Modelo FORK</strong>:<br>
El servidor FORK ofreció un rendimiento intermedio, con tiempos de respuesta más rápidos que FIFO, pero con un mayor consumo de memoria y CPU en comparación con THREAD. Es una opción viable para sistemas con recursos suficientes.</p>
</li>
<li>
<p><strong>Conexiones Exitosas y Manejo de Errores</strong>:<br>
Todos los modelos lograron manejar el 100% de las conexiones exitosamente y respondieron adecuadamente a errores, lo que demuestra la robustez de las implementaciones.</p>
</li>
<li>
<p><strong>Pruebas Uniformes</strong>:<br>
Los datos fueron obtenidos utilizando la misma prueba en los diferentes servidores, garantizando así una comparación justa y consistente entre los modelos.</p>
</li>
</ol>
<p>En pocas palabras, el modelo THREAD es el más adecuado para escenarios de alta concurrencia, mientras que FIFO y FORK pueden ser útiles en casos específicos dependiendo de los recursos disponibles y los requisitos del sistema.</p>
<h2 id="casos-de-prueba"><strong>Casos de Prueba</strong></h2>
<p>A continuación, se describen las pruebas realizadas para evaluar la funcionalidad completa del programa, incluyendo los resultados esperados y los obtenidos.</p>
<h3 id="prueba-1-solicitud-b%C3%A1sica"><strong>Prueba 1: Solicitud Básica</strong></h3>
<h4 id="descripci%C3%B3n-solicitar-varios-archivos-peque%C3%B1os-desde-el-cliente"><strong>Descripción:</strong> Solicitar varios archivos pequeños desde el cliente.</h4>
<h4 id="comando"><strong>Comando:</strong></h4>
<pre class="hljs"><code><div>./cliente_http noticia.txt mi_archivo.txt html_ejemplo.html golden.png
</div></code></pre>
<h4 id="resultado-esperado"><strong>Resultado Esperado:</strong></h4>
<ul>
<li>Los archivos solicitados se descargan correctamente en el directorio del cliente.</li>
<li>El servidor responde con código HTTP 200 OK para cada archivo.</li>
</ul>
<h4 id="resultado-obtenido"><strong>Resultado Obtenido:</strong></h4>
<ul>
<li>✅ Todos los archivos se descargaron correctamente.</li>
<li>✅ Respuesta del servidor: 200 OK para cada archivo.</li>
</ul>
<img src="file:///mnt/c/Users/Mariana Fern&#xE1;ndez M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-5.png" alt="alt text" width="800">
<img src="file:///mnt/c/Users/Mariana Fern&#xE1;ndez M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-6.png" alt="alt text" width="600">
<img src="file:///mnt/c/Users/Mariana Fern&#xE1;ndez M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-7.png" alt="alt text" width="600">
<h3 id="prueba-2-archivo-grande-25gb"><strong>Prueba 2: Archivo Grande (2.5GB)</strong></h3>
<h4 id="descripci%C3%B3n-solicitar-un-archivo-grande-para-evaluar-el-manejo-de-transferencias-extensas"><strong>Descripción:</strong> Solicitar un archivo grande para evaluar el manejo de transferencias extensas.</h4>
<h4 id="comando"><strong>Comando:</strong></h4>
<pre class="hljs"><code><div>dd <span class="hljs-keyword">if</span>=/dev/zero of=archivos/prueba_grande.bin bs=1G count=2
./cliente_http prueba_grande.bin
</div></code></pre>
<h4 id="resultado-esperado"><strong>Resultado Esperado:</strong></h4>
<ul>
<li>El archivo se descarga completamente sin interrupciones.</li>
<li>El servidor mantiene la conexión activa hasta completar la transferencia.</li>
</ul>
<h4 id="resultado-obtenido"><strong>Resultado Obtenido:</strong></h4>
<ul>
<li>✅ El archivo se descargó completamente.</li>
<li>✅ El servidor mantuvo la conexión activa durante toda la transferencia.</li>
</ul>
<img src="file:///mnt/c/Users/Mariana Fern&#xE1;ndez M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-8.png" alt="alt text" width="800">
<img src="file:///mnt/c/Users/Mariana Fern&#xE1;ndez M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-9.png" alt="alt text" width="800">
<img src="file:///mnt/c/Users/Mariana Fern&#xE1;ndez M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-10.png" alt="alt text" width="800">
<h3 id="prueba-3-stress-test"><strong>Prueba 3: Stress Test</strong></h3>
<h4 id="descripci%C3%B3n-simular-m%C3%BAltiples-clientes-concurrentes-solicitando-archivos-al-servidor"><strong>Descripción:</strong> Simular múltiples clientes concurrentes solicitando archivos al servidor.</h4>
<h4 id="comando"><strong>Comando:</strong></h4>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> {1..50}; <span class="hljs-keyword">do</span> ./cliente_http file<span class="hljs-variable">$i</span>.txt &amp; <span class="hljs-keyword">done</span>
</div></code></pre>
<h4 id="resultado-esperado"><strong>Resultado Esperado:</strong></h4>
<ul>
<li>El servidor maneja todas las solicitudes sin fallar.</li>
<li>Los archivos se descargan correctamente.</li>
</ul>
<h4 id="resultado-obtenido"><strong>Resultado Obtenido:</strong></h4>
<ul>
<li>✅ El servidor manejó todas las solicitudes sin errores.</li>
<li>✅ Todos los archivos se descargaron correctamente.</li>
</ul>
<img src="file:///mnt/c/Users/Mariana Fern&#xE1;ndez M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-11.png" alt="alt text" width="800">
<img src="file:///mnt/c/Users/Mariana Fern&#xE1;ndez M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-12.png" alt="alt text" width="400">
<h3 id="prueba-4-solicitud-de-archivo-inexistente"><strong>Prueba 4: Solicitud de Archivo Inexistente</strong></h3>
<h4 id="descripci%C3%B3n-solicitar-un-archivo-que-no-existe-en-el-servidor"><strong>Descripción:</strong> Solicitar un archivo que no existe en el servidor.</h4>
<h4 id="comando"><strong>Comando:</strong></h4>
<pre class="hljs"><code><div>./cliente_http archivo_inexistente.txt
</div></code></pre>
<h4 id="resultado-esperado"><strong>Resultado Esperado:</strong></h4>
<ul>
<li>El servidor responde con código HTTP 404 Not Found.</li>
<li>No se genera ningún archivo en el cliente.</li>
</ul>
<h4 id="resultado-obtenido"><strong>Resultado Obtenido:</strong></h4>
<ul>
<li>✅ Respuesta del servidor: 404 Not Found.</li>
<li>✅ No se generó ningún archivo en el cliente.</li>
</ul>
<img src="file:///mnt/c/Users/Mariana Fern&#xE1;ndez M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-1.png" alt="alt text" width="800">
<img src="file:///mnt/c/Users/Mariana Fern&#xE1;ndez M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image.png" alt="alt text" width="600">
<h2 id="comparativa-t%C3%A9cnica"><strong>Comparativa Técnica</strong></h2>
<p>En la siguiente tabla se presenta una comparación entre los hilos de Java y Pthreads, dos enfoques populares para la programación concurrente. Esta comparación se centra en aspectos clave como usabilidad, portabilidad, rendimiento y manejo de errores.</p>
<table>
<thead>
<tr>
<th><strong>Aspecto</strong></th>
<th><strong>Java Threads</strong></th>
<th><strong>Pthreads</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Usabilidad</strong></td>
<td>Ofrece una API de alto nivel, fácil de usar y adecuada para desarrolladores Java.</td>
<td>Requiere conocimientos avanzados de programación en C y manejo de bajo nivel.</td>
</tr>
<tr>
<td><strong>Portabilidad</strong></td>
<td>Multiplataforma, funciona en cualquier sistema con una JVM.</td>
<td>Dependiente del sistema operativo, diseñado principalmente para entornos POSIX.</td>
</tr>
<tr>
<td><strong>Rendimiento</strong></td>
<td>Mayor overhead debido a la abstracción de la JVM.</td>
<td>Más eficiente en términos de uso de recursos, con menor overhead.</td>
</tr>
<tr>
<td><strong>Sincronización</strong></td>
<td>Utiliza monitores y palabras clave como <code>synchronized</code> para manejar concurrencia.</td>
<td>Requiere el uso explícito de mutexes y variables de condición.</td>
</tr>
<tr>
<td><strong>Memoria por Hilo</strong></td>
<td>Consume más memoria (~1 MB por hilo) debido a la sobrecarga de la JVM.</td>
<td>Consume menos memoria (~8 KB por hilo), ideal para aplicaciones de alto rendimiento.</td>
</tr>
<tr>
<td><strong>Creación de Hilos</strong></td>
<td>Más lenta debido a la inicialización de la JVM y la gestión de recursos.</td>
<td>Más rápida, ya que interactúa directamente con el sistema operativo.</td>
</tr>
<tr>
<td><strong>Depuración</strong></td>
<td>Más sencilla gracias a herramientas integradas en entornos como Eclipse o IntelliJ.</td>
<td>Más compleja, requiere herramientas externas como GDB para depuración.</td>
</tr>
<tr>
<td><strong>Escalabilidad</strong></td>
<td>Adecuada para aplicaciones multiplataforma con requisitos moderados de concurrencia.</td>
<td>Ideal para aplicaciones de alto rendimiento en sistemas específicos.</td>
</tr>
<tr>
<td><strong>Manejo de Errores</strong></td>
<td>Manejo de excepciones integrado en el lenguaje.</td>
<td>Requiere manejo manual de errores mediante códigos de retorno.</td>
</tr>
</tbody>
</table>
<p>En resumen, los hilos de Java son más accesibles y portables, ideales para aplicaciones multiplataforma. Por otro lado, Pthreads ofrece un rendimiento superior y un control más detallado, siendo más adecuado para sistemas críticos y de alto rendimiento.</p>
<h2 id="evaluaci%C3%B3n"><strong>Evaluación</strong></h2>
<p>Durante la implementación se aprendió a trabajar con sockets, manejar procesos e hilos en C, y simular un entorno servidor-cliente funcional.</p>
<ul>
<li>
<p>El servidor FIFO fue el más sencillo de implementar, pero el menos eficiente. Entre sus ventajas se tiene un bajo consumo de recursos y facilidad de depuración. Sin embargo no es viable para cargas altas.</p>
</li>
<li>
<p>El servidor FORK ofreció buena concurrencia, aunque requiere manejo cuidadoso de procesos hijos. Entre sus ventajas se encuentran la facilidad de implementación y la capacidad de manejar múltiples solicitudes simultáneamente. Sin embargo, su alto consumo de memoria y CPU lo hacen menos eficiente.</p>
</li>
<li>
<p>El servidor THREAD mostró el mejor rendimiento general, con menor sobrecarga que FORK. Entre sus ventajas se tiene que consume menos recursos y es más eficiente en el uso de CPU. Sin embargo, su implementación es más compleja y requiere un manejo cuidadoso de condiciones de carrera.</p>
</li>
</ul>
<p>En conclusión, el servidor THREAD fue el que mejor atendió múltiples solicitudes simultáneas con eficiencia y estabilidad.</p>
<h2 id="manual-de-usuario"><strong>Manual de Usuario</strong></h2>
<p>Asegúrese de estar en un ambiente Linux. Puede ser WSL en VSCode o una máquina virtual.</p>
<h3 id="compilaci%C3%B3n"><strong>Compilación</strong></h3>
<pre class="hljs"><code><div>make clean &amp;&amp; make
</div></code></pre>
<p>Esto ejecutará el Makefile, compilará el código y lo dejará listo para su ejecución.</p>
<p><img src="file:///mnt/c/Users/Mariana Fernández M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-2.png" alt="alt text"></p>
<h3 id="ejecuci%C3%B3n"><strong>Ejecución</strong></h3>
<h4 id="servidor"><strong>Servidor</strong></h4>
<p>En una terminal, ejecute el servidor que desea utilizar. Solo se puede usar un servidor a la vez, ya que comparten el mismo puerto:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Servidor de elección</span>
./server_fifo

./server_thread

./server_fork
</div></code></pre>
<p><img src="file:///mnt/c/Users/Mariana Fernández M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-3.png" alt="alt text"></p>
<h4 id="cliente"><strong>Cliente</strong></h4>
<p>En otra terminal diferente, ejecute el cliente con los archivos que desea procesar:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Cliente</span>
./cliente_http noticia.txt
</div></code></pre>
<p><img src="file:///mnt/c/Users/Mariana Fernández M/Documents/GitHub/proyecto-cliente-servidor-c/docs/image-4.png" alt="alt text"></p>
<h2 id="bit%C3%A1cora-de-trabajo"><strong>Bitácora de Trabajo</strong></h2>
<p>La siguiente tabla resume las horas invertidas en cada actividad del proyecto.</p>
<table>
<thead>
<tr>
<th><strong>Fecha</strong></th>
<th><strong>Actividad</strong></th>
<th style="text-align:center"><strong>Horas</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>30/03/2025</td>
<td>Revisión de requisitos</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>30/03/2025</td>
<td>Configuración del entorno</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td>30/03/2025</td>
<td>Creación del repositorio</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>30/03/2025</td>
<td>Estructura del proyecto</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td>02/04/2025</td>
<td>Diseño de arquitectura</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td>05/04/2025</td>
<td>Implementación FIFO</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td>08/04/2025</td>
<td>Implementación FORK</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td>10/04/2025</td>
<td>Implementación THREAD</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td>11/04/2025</td>
<td>Implementación Cliente</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td>12/04/2025</td>
<td>Pruebas de funcionalidad</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td>12/04/2025</td>
<td>Documentación</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td>13/04/2025</td>
<td>Pruebas de estrés</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td>14/04/2025</td>
<td>Revisión de documentación</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td>14/04/2025</td>
<td>Revisión final</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td>15/04/2025</td>
<td>Entrega del proyecto</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<h2 id="conclusiones"><strong>Conclusiones</strong></h2>
<p>El proyecto permitió aplicar conceptos clave de sistemas operativos como sockets, procesos e hilos. Se concluye lo siguiente:</p>
<ul>
<li>El servidor THREAD fue el más eficiente y estable al manejar múltiples solicitudes concurrentes.</li>
<li>El servidor FIFO, aunque simple, es poco escalable.</li>
<li>El modelo FORK funciona bien, pero con mayor sobrecarga que THREAD.</li>
<li>El cliente multihilo facilitó la descarga paralela de archivos.</li>
<li>La correcta división del trabajo y las pruebas colaborativas fueron clave para el éxito del proyecto.</li>
</ul>
<h2 id="referencias"><strong>Referencias</strong></h2>
<ol>
<li>Stevens, W. R. (2003). <em>UNIX Network Programming</em></li>
<li>RFC 1945 - HTTP/1.0</li>
<li>Comer, D. E. (2000). <em>Internetworking with TCP/IP Volume III: Client-Server Programming and Applications</em>. Prentice Hall.</li>
<li>Kerrisk, M. (2010). <em>The Linux Programming Interface: A Linux and UNIX System Programming Handbook</em>. No Starch Press.</li>
<li>Postel, J. (1981). <em>RFC 793 - Transmission Control Protocol</em>. Retrieved from https://www.rfc-editor.org/rfc/rfc793.html</li>
<li>Postel, J. (1996). <em>RFC 1945 - Hypertext Transfer Protocol -- HTTP/1.0</em>. Retrieved from https://www.rfc-editor.org/rfc/rfc1945.html</li>
<li>Stevens, W. R., Fenner, B., &amp; Rudoff, A. M. (2004). <em>UNIX Network Programming, Volume 1: The Sockets Networking API</em>. Addison-Wesley.</li>
<li>GNU Project. (n.d.). <em>GNU C Library: Sockets</em>. Retrieved from https://www.gnu.org/software/libc/manual/html_node/Sockets.html</li>
<li>Beej's Guide to Network Programming. (n.d.). Retrieved from https://beej.us/guide/bgnet/</li>
<li>Goetz, B. (2006). <em>Java Concurrency in Practice</em>. Addison-Wesley.</li>
<li>Butenhof, D. R. (1997). <em>Programming with POSIX Threads</em>. Addison-Wesley.</li>
<li>Oracle. (n.d.). <em>Java Threads Documentation</em>. Retrieved from https://docs.oracle.com/javase/tutorial/essential/concurrency/</li>
<li>The Open Group. (n.d.). <em>POSIX Threads Documentation</em>. Retrieved from https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html</li>
</ol>

</body>
</html>
